- There is a signal mask associated with each user level thread which is associated with the user level process and is visible to the user level library. 
- There is also a signal mask that is associated with the kernel level thread and that kernel level mask is only visible to the kernel.
- When a user level thread wants to disable a signal, it clears the appropriate bit in the signal mask, which occurs at user level. The kernel level mask is not updated.
- When a signal occurs, the kernel needs to know what to do with the signal. The kernel mask may have that signal bit set to one, so from the kernel's point of view, the signal is still enabled.
- If we don't want to have to make a system call, crossing from user level into kernel level each time a user level threads updates the signal mask, we need to come up with some kind of policy.
## Case 1
![[Pasted image 20240921164158.png]]
If both the kernel level thread and the user level thread have the bit enabled, the kernel will send the signal up to the user level thread and we have no problem.

## Case 2 

![[Pasted image 20240921164519.png]]
-  kernel level thread has a particular signal bit enabled, and the currently executing user level thread does not. However, there is a runnable user level thread that does have the bit enabled.
- What we would like to do is to be able to stop the thread that cannot handle the signal, and start the thread that can.
- library handling routine to wrap and can see all the ULT's mask
- We can achieve this by having the **user level threading library** invoked by library handling routine. This way, when the signal occurs, the library can invoke the scheduler to swap in a thread that can handle the signal. Once this thread is executing, the signal is passed to its handler.

## Case 3

![[Pasted image 20240921165226.png]]

In the case where a signal is generated by a kernel level thread that is executing on behalf of a user level thread which does not have the bit enabled, the threading library will know that it cannot pass the signal to this particular user thread.

What it can do, however, is send a directed signal down to the kernel level thread associated with the user level thread that has the bit enabled. This will cause that kernel level thread to raise the same signal, which will be handled again by the user level library and dispatched to the user level thread that has the bit enabled.

## Case 4
![[Pasted image 20240923212150.png]]

- Let's consider the final case in which every single user thread has the particular signal disabled. The kernel level masks are still 1, so the kernel still thinks that the process as a whole can handle the signal.

- When the signal occurs, the kernel interrupts the execution of whichever thread is currently executing atop it. The library handling routine kicks in and sees that no threads that it manages can handle this pzarticular signal.
- At this point, the thread library will make a system call requesting that the kernel level thread change its signal mask for this particular signal, disabling it.

- If we have multiple kernel level threads associated with our process, the thread library will reissue the signal 
- At some point in time, a user level thread may decide to re-enable a particular signal. At this point, the user level library must again make a system call, and tell the kernel level thread to update its signal mask for this particular signal, enabling it.
## Optimize for common case
-  Signals themselves occur much less frequently than does the need to update the signal mask. 
- Updates of the signal mask are cheap. 
- They occur at the user level and avoid system calls. 
- Signal handling becomes more expensive - as system calls may be needed to correct discrepancies - but they occur less frequently so the added cost is acceptable.

